---
layout: post
title: NodeJs Overview
date: 2016-10-06 12:00:00
categories: programming
comments: true
en: true
description: An Overview of NodeJs
keywords: "nodejs overview, nodejs cheat sheet"
authors:
    - Edgar Montano
---

## Table of contents

* toc
{:toc}

## How Node.js works

Node.js is Asynchronous and is single-threaded. All of the users are sharing the same thread. Events are raised and recorded in an event queue and then handled in the order that they were raised.

## Global object

```
var path = require('path'); //require is another global object
console.log(__dirname); //__dirname global object
console.log(__filename); // __filename  global object
console.log(path.basename(__filename));
console.log(process.argv);
```

## Argument variables

```
console.log(process.argv);
function grab(flag){
    var index = process.agrv.indexOf(flag);
    return (index === -1) ? null : process.argv[index+1];
}
grab('--p'); // run commandline node filename --p localhost
```

## Standard IO

```
process.stdout.write('\n>');
process.stdin.on('data',function(data){

});
```

## Timing

Global timing functions are made available in Node.js .

```
var waitTime = 3000;
var currentTime = 0 ;
var waitInterval = 500;
var percentWaiting = 0;

console.log('waiting..');

function writePercent(p){
  process.stdout.clearLine();
  process.stdout.cursorTo(0);
  process.stdout.write(`Waiting ... ${p}%`);
}


var interval = setInterval(function(){
  currentTime += waitInterval;
  writePercent(Math.floor(currentTime/waitTime *100));
  //console.log(`waiting ${currentTime/1000}`);
},waitInterval);



setTimeout(function(){
  clearInterval(interval);
  writePercent(100);
  console.log('\nProcess is done');

}, waitTime);

process.stdout.write("\n\n\n\n");
writePercent(percentWaiting);
```

## Core modueles

Doesn't require npm install, they are included in node.js

```
var path = require('path');
console.log(path.basename(__filename));

var dirExample = path.join(__dirname, 'www', 'files', 'uploads');
console.log(dirExample);

var util = require('util');
util.log(dirExample);

var v8 = require('v8');
util.log(v8.getHeapStatistics());

```

## Event Emitter

```
var Person = function(name){
  this.name = name;
};

util.inherits(Person,EventEmitter); //add EventEmitter and functionality to person
var john = new Person('John Doe');

john.on('speak', function(said){
  console.log(`${this.name} said ${said}\n`);
});


john.emit('speak', "Hello World");
```

## Readline

```
var readline = require('readline');

var rl = readline.createInterface(process.stdin, process.stdout);
var listSayings = [];

rl.question("What is your name? ", function(answer){
  rl.setPrompt(`What would ${answer} say? `);
  rl.prompt();
  rl.on('line',function(saying){
    rl.setPrompt(`What else would ${answer} say? `);

    if(saying.toLowerCase().trim() === 'exit'){
      rl.close();
    }

    listSayings.push(saying.trim());
    rl.prompt();

  });

});

rl.on('close',function(){
  listSayings.forEach(function(element){
    console.log("They would say ", element);
  });
  process.exit();
});
```

## Event-Driven Programming with Asynchronous calls

Is a programming style whereby the flow is determined by the occurence of events. Programmers register callbacks to be used as event handlers for events.  The system invokes these handlers when those events occur.

## Closures
 Closures are functions that inherit variables from their enclosing environment.  In javascript functions are first-class objects, which means you can pass functions as arguments to other functions. You should avoid using global scope pollution by wrapping all of your code inside another function to create an additional closure.

 In event driven programming you start by defining the code that will be executed when an event occurs, then put that code inside a function, and finally pass that function as an argument to be called later.

 With event driven programming you do not have to maintain the state by passing it around to functions. A javascript closure will keep the state for you.

 ```
 (function(){
   var count = 0;
   document.getElementById('myButton').onClick = function(){
     count += 1;
     alert(count);
   };
}());
 ```

## Understanding Callback pattern

Asynchronous programming does not use function return values to denote that a function is finished. Instead it uses the continuation passing style (CPS).

CPS is a style of programmnig which is passed explicitly in the form of a continuation.  A function written in CPS takes as an argument an explicit "continuation" that is a function one argument. When the CPS function has comptued its result, it returns by calling the continuation function with this value as the argument.


## Exec

```
var exec = require('child_process').exec;

exec("ls", function(err, stdout){
  if(err) throw err;
  console.log(stdout);
});
```

## Spawn

Useful for long on-going processes opposed to exec which should be short sequenced functions. 

```
```
